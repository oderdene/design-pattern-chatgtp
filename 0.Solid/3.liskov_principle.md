Here's a practical example of the **Liskov Substitution Principle (LSP)** in code. Let's imagine a simple hierarchy for shapes.

### Example: Shapes and Areas

You have a `Shape` class and specific shapes like `Rectangle` and `Square`. The principle requires that if `Square` inherits from `Rectangle`, it should behave like a `Rectangle` without surprises.

#### Violation of LSP:

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def set_width(self, width):
        self.width = width

    def set_height(self, height):
        self.height = height

    def get_area(self):
        return self.width * self.height

# Square inherits Rectangle
class Square(Rectangle):
    def set_width(self, width):
        self.width = width
        self.height = width  # Ensure it's always a square

    def set_height(self, height):
        self.height = height
        self.width = height  # Ensure it's always a square

# Using the classes
def print_area(rect):
    rect.set_width(4)
    rect.set_height(5)
    print(f"Area: {rect.get_area()}")

rect = Rectangle(0, 0)
print_area(rect)  # Area: 20

square = Square(0, 0)
print_area(square)  # Surprise! Area: 25 (Not what we expect for a 4x5 rectangle)
```

#### Problem:

In the example above, the `Square` class doesn’t behave like a `Rectangle`. The `set_width` and `set_height` methods in `Square` change both dimensions, which breaks the expectations for `Rectangle`.

---

#### Correct Design:

Instead of violating LSP, we can refactor the code to avoid inheritance where it doesn't make sense.

```python
class Shape:
    def get_area(self):
        raise NotImplementedError("Subclasses should implement this method")

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def set_width(self, width):
        self.width = width

    def set_height(self, height):
        self.height = height

    def get_area(self):
        return self.width * self.height

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def set_side(self, side):
        self.side = side

    def get_area(self):
        return self.side * self.side

# Using the classes
def print_area(shape):
    print(f"Area: {shape.get_area()}")

rect = Rectangle(4, 5)
print_area(rect)  # Area: 20

square = Square(4)
print_area(square)  # Area: 16 (Works as expected)
```

#### Explanation:

1. `Square` and `Rectangle` are no longer forced into an inappropriate inheritance relationship.
2. The `print_area` function works for any `Shape`, following the expectations set by their individual implementations.
3. The Liskov Substitution Principle is satisfied because you can replace `Rectangle` or `Square` with their parent `Shape` without breaking the program’s logic.
