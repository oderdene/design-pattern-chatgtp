## 9. Are there alternative ways to implement the singleton design pattern?

Absolutely — Python is super flexible, and besides the common implementations, there are several **alternative ways to implement the Singleton pattern**, each with its own style and use case.

Here are some **less common but interesting alternatives**, along with examples:

---

## 🔁 1. **Using a Module as a Singleton (Pythonic Way)**

> **Modules in Python are singletons by nature.**

```python
# config.py
settings = {
    "theme": "dark",
    "version": "1.0"
}

def get_setting(key):
    return settings.get(key)
```

```python
# main.py
import config

print(config.get_setting("theme"))  # dark
```

✅ **Pros:**

- Simple, built-in singleton behavior
- No custom code or class needed

🚫 **Cons:**

- Not as flexible if you want inheritance or more control

---

## 🛠️ 2. **Using a Borg Pattern (Shared State)**

> Instead of enforcing a single instance, all instances share the same state.

```python
class Borg:
    _shared_state = {}

    def __init__(self):
        self.__dict__ = self._shared_state

class AppSettings(Borg):
    def __init__(self):
        super().__init__()
        self.setting = "default"

# Test
a = AppSettings()
b = AppSettings()

a.setting = "dark"
print(b.setting)  # dark
print(a is b)     # False — but they share the same state
```

✅ **Pros:**

- Multiple instances, but shared state
- Flexible and test-friendly

🚫 **Cons:**

- May be confusing to some developers expecting a single instance

---

## 🔄 3. **Using a Global Variable**

```python
class Printer:
    def print_text(self, text):
        print(text)

printer_instance = Printer()

# Anywhere in the app:
# from printer_module import printer_instance
printer_instance.print_text("Hello")
```

✅ **Pros:**

- Super simple
- No need for Singleton logic

🚫 **Cons:**

- Global variables can be harder to track, test, or mock

---

## ⚙️ 4. **Using `functools.lru_cache()` (for lazy single instantiation)**

```python
from functools import lru_cache

@lru_cache(maxsize=1)
def get_logger():
    class Logger:
        def log(self, msg):
            print(f"[LOG]: {msg}")
    return Logger()

# Test
logger1 = get_logger()
logger2 = get_logger()
print(logger1 is logger2)  # True
```

✅ **Pros:**

- Lazy initialization
- No need for a class-level static variable

🚫 **Cons:**

- Not as clear as a class-based Singleton
- Limited customization

---

## Summary Table

| Method          | Singleton Instance | Shared State | Lazy | Simple | Thread-Safe |
| --------------- | ------------------ | ------------ | ---- | ------ | ----------- |
| Module          | ✅                 | ❌           | ✅   | ✅     | ✅          |
| Borg Pattern    | ❌ (multiple objs) | ✅           | ❌   | ⚠️     | ❌          |
| Global Variable | ✅ (manually)      | ❌           | ❌   | ✅     | ❌          |
| `lru_cache`     | ✅                 | ❌           | ✅   | ✅     | ⚠️          |

---

Let me know if you want a **thread-safe version** or if you're targeting a specific use case (e.g. async code, config, service locator, etc.) and I can tailor the singleton implementation for it!
