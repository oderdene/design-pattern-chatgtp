## 7. What is the structure or UML diagram of this pattern?

### **Structure of the Factory Design Pattern (UML Diagram)**
The **Factory Design Pattern** follows a structured approach where a **Factory** is responsible for creating objects that adhere to a common **interface** or **abstract class**.

Hereâ€™s a typical **UML diagram** representation of the **Factory Pattern**:

```plaintext
        +-------------------+
        |    Product        |  <----- Interface / Abstract Class
        +-------------------+
        | + operation()     |
        +-------------------+
                â–²
                â”‚
    -----------------------
    |                     |
+----------------+  +----------------+
| ConcreteProductA |  | ConcreteProductB |
+----------------+  +----------------+
| + operation()  |  | + operation()  |
+----------------+  +----------------+

        +-------------------+
        |   Factory         |  <---- Factory Class (Creator)
        +-------------------+
        | + createProduct() |
        +-------------------+
                â”‚
                â–¼
        +---------------------+
        |    Client           |  <---- Uses the Factory
        +---------------------+
        | - Calls factory     |
        +---------------------+
```

---

### **Explanation of Components in UML**
1. **Product (Abstract Class / Interface)**  
   - Defines the common behavior for all concrete products.  
   - Example: `Shape` (with a method like `draw()`).

2. **Concrete Products (Implementations)**  
   - Implement the `Product` interface or extend an abstract class.  
   - Example: `Circle`, `Square`, `Triangle`.

3. **Factory (Creator Class)**  
   - Provides a static method (or instance method) to create objects of `ConcreteProduct` without exposing instantiation logic to the client.  
   - Example: `ShapeFactory.createShape(String type)`.

4. **Client (User of Factory)**  
   - Calls the **Factory** instead of using `new` to create objects.  
   - Works with the `Product` interface, ensuring loose coupling.

---

### **Example in Java**
```java
// 1. Product Interface
interface Shape {
    void draw();
}

// 2. Concrete Products
class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing a Circle");
    }
}

class Square implements Shape {
    public void draw() {
        System.out.println("Drawing a Square");
    }
}

// 3. Factory Class
class ShapeFactory {
    public static Shape createShape(String type) {
        if (type.equalsIgnoreCase("CIRCLE")) return new Circle();
        if (type.equalsIgnoreCase("SQUARE")) return new Square();
        throw new IllegalArgumentException("Unknown shape type");
    }
}

// 4. Client
public class FactoryPatternExample {
    public static void main(String[] args) {
        Shape shape1 = ShapeFactory.createShape("CIRCLE");
        shape1.draw();  // Output: Drawing a Circle

        Shape shape2 = ShapeFactory.createShape("SQUARE");
        shape2.draw();  // Output: Drawing a Square
    }
}
```

---

### **Key Takeaways**
âœ” **Encapsulation** â†’ Object creation logic is hidden from the client.  
âœ” **Loose Coupling** â†’ Client depends on the `Product` interface, not concrete classes.  
âœ” **Open/Closed Principle** â†’ New `ConcreteProduct` classes can be added without modifying existing code.  

Would you like me to generate a visual UML diagram for you? ðŸš€