## 8. How is this pattern implemented in a programming language you know?

Here's how the **Factory Design Pattern** is implemented in **Java** and **Python**:

---

## **1Ô∏è‚É£ Java Implementation**
Java is **statically typed**, so we use **interfaces** and **class hierarchies** for the Factory Pattern.

### **Step 1: Define the Product Interface**
```java
// Product Interface
interface Shape {
    void draw();
}
```

### **Step 2: Create Concrete Products**
```java
// Concrete Product 1
class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing a Circle");
    }
}

// Concrete Product 2
class Square implements Shape {
    public void draw() {
        System.out.println("Drawing a Square");
    }
}
```

### **Step 3: Create the Factory Class**
```java
// Factory Class
class ShapeFactory {
    public static Shape createShape(String type) {
        if (type.equalsIgnoreCase("CIRCLE")) return new Circle();
        if (type.equalsIgnoreCase("SQUARE")) return new Square();
        throw new IllegalArgumentException("Unknown shape type");
    }
}
```

### **Step 4: Use the Factory in the Client Code**
```java
public class FactoryPatternExample {
    public static void main(String[] args) {
        Shape shape1 = ShapeFactory.createShape("CIRCLE");
        shape1.draw();  // Output: Drawing a Circle

        Shape shape2 = ShapeFactory.createShape("SQUARE");
        shape2.draw();  // Output: Drawing a Square
    }
}
```
‚úÖ **Key Takeaways:**  
‚úî Encapsulation: Object creation is hidden.  
‚úî Loose Coupling: Client does not depend on concrete classes.  
‚úî Easy to extend: Adding a `Rectangle` class requires no changes to the factory method.

---

## **2Ô∏è‚É£ Python Implementation**
Python is **dynamically typed**, so we don't need explicit interfaces. We use **duck typing** instead.

### **Step 1: Define Concrete Products**
```python
# Concrete Products
class Circle:
    def draw(self):
        print("Drawing a Circle")

class Square:
    def draw(self):
        print("Drawing a Square")
```

### **Step 2: Create the Factory**
```python
class ShapeFactory:
    @staticmethod
    def create_shape(shape_type):
        if shape_type.lower() == "circle":
            return Circle()
        elif shape_type.lower() == "square":
            return Square()
        else:
            raise ValueError("Unknown shape type")
```

### **Step 3: Use the Factory in the Client Code**
```python
if __name__ == "__main__":
    shape1 = ShapeFactory.create_shape("circle")
    shape1.draw()  # Output: Drawing a Circle

    shape2 = ShapeFactory.create_shape("square")
    shape2.draw()  # Output: Drawing a Square
```

‚úÖ **Key Takeaways:**  
‚úî No need for explicit interfaces in Python (dynamic typing).  
‚úî Factory centralizes object creation.  
‚úî Easily extendable for new shapes.

---

### **Comparison of Java and Python Implementation**
| Feature           | Java                                      | Python                              |
|------------------|---------------------------------|---------------------------------|
| Typing           | Statically Typed                  | Dynamically Typed               |
| Interfaces       | Uses explicit interface (`Shape`) | No need for interfaces (duck typing) |
| Object Creation | Uses `new` keyword                 | Instantiates directly in factory |
| Factory Method  | `public static Shape createShape()` | `@staticmethod create_shape()` |

Would you like an implementation in another language, such as JavaScript or C++? üöÄ