## 2. What is the primary intent of this pattern?
â€œÐ­Ð½Ñ Ð·Ð°Ð³Ð²Ð°Ñ€Ñ‹Ð½ Ò¯Ð½Ð´ÑÑÐ½ Ð·Ð¾Ñ€Ð¸Ð»Ð³Ð¾ ÑŽÑƒ Ð²Ñ?â€

The **primary intent** of the **Factory Pattern** is to **encapsulate object creation** and provide a way to create objects **without specifying their exact class**. 
â€œFactory Pattern-Ð¸Ð¹Ð½ Ò¯Ð½Ð´ÑÑÐ½ Ð·Ð¾Ñ€Ð¸Ð»Ð³Ð¾ Ð½ÑŒ Ð¾Ð±ÑŠÐµÐºÑ‚ Ò¯Ò¯ÑÐ³ÑÑ… Ò¯Ð¹Ð» ÑÐ²Ñ†Ñ‹Ð³ Ð½ÑƒÑƒÑ… (encapsulate) Ð±Ó©Ð³Ó©Ó©Ð´ Ñ‚ÑƒÑ…Ð°Ð¹Ð½ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¸Ð¹Ð³ ÑÐ³ ÑÐ¼Ð°Ñ€ ÐºÐ»Ð°ÑÑÐ°Ð°Ñ Ò¯Ò¯ÑÐ³ÑÐ¶ Ð±Ð°Ð¹Ð³Ð°Ð°Ð³ Ð·Ð°Ð°Ñ…Ð³Ò¯Ð¹Ð³ÑÑÑ€ Ò¯Ò¯ÑÐ³ÑÑ… Ð°Ñ€Ð³Ð° Ð·Ð°Ð¼Ñ‹Ð³ Ñ…Ð°Ð½Ð³Ð°Ñ… ÑÐ²Ð´Ð°Ð» ÑŽÐ¼.â€

### **Key Goals:**  
1. **Encapsulation of Object Creation** â†’ The factory handles object creation logic in one place.  
2. **Loose Coupling** â†’ The client code depends on an interface or abstract class, not concrete implementations.  
3. **Easier Maintenance & Scalability** â†’ Adding new object types doesnâ€™t require modifying existing code.  
4. **Improved Code Reusability** â†’ The same factory can be used to create multiple object types.  

### **Simple Analogy:**  
Instead of manually assembling a car every time (direct object creation), you go to a **car factory** that builds the right model for you based on your request. ðŸš—

## 3. Is this pattern categorized as creational, structural, or behavioral? Why?
The **Factory Pattern** is categorized as a **Creational** design pattern.  

### **Why?**  
- It focuses on **how objects are created**.  
- Instead of directly instantiating objects using `new`, it provides a controlled way to create them.  
- It ensures that object creation is **centralized, flexible, and reusable**, which is the main goal of creational patterns.  

### **Comparison with Other Categories:**  
- **Structural Patterns** â†’ Focus on organizing relationships between classes (e.g., Adapter, Decorator). ÐºÐ»Ð°ÑÑÑƒÑƒÐ´Ñ‹Ð½ Ñ…Ð¾Ð¾Ñ€Ð¾Ð½Ð´Ñ‹Ð½ Ñ…Ð°Ñ€Ð¸Ð»Ñ†Ð°Ð°Ð³ Ð·Ð¾Ñ…Ð¸Ð¾Ð½ Ð±Ð°Ð¹Ð³ÑƒÑƒÐ»Ð°Ñ…Ð°Ð´
- **Behavioral Patterns** â†’ Focus on communication between objects (e.g., Strategy, Observer). Ð¾Ð±ÑŠÐµÐºÑ‚ÑƒÑƒÐ´Ñ‹Ð½ Ñ…Ð¾Ð¾Ñ€Ð¾Ð½Ð´Ñ‹Ð½ Ñ…Ð°Ñ€Ð¸Ð»Ñ†Ð°Ð°Ð½Ð´

Since the Factory Pattern is all about **creating objects efficiently**, it belongs to the **Creational** category. ðŸ­


## 4. What are some real-world analogies for this pattern?

Here are some **real-world analogies** for the **Factory Pattern**:  

### 1ï¸âƒ£ **Coffee Machine â˜•**  
   - Instead of manually mixing coffee, milk, and sugar every time, you press a button for "Espresso" or "Cappuccino."  
   - The machine (factory) decides how to **prepare** and **deliver** the right drink.  
   - **Factory Role:** It hides the complex process and provides the correct coffee based on your request.  

### 2ï¸âƒ£ **Car Factory ðŸš—**  
   - You order a "Sedan" or "SUV," and the factory builds the right model.  
   - You donâ€™t assemble it yourselfâ€”the factory ensures you get the correct car.  
   - **Factory Role:** It abstracts away the manufacturing details and delivers the correct vehicle.  

### 3ï¸âƒ£ **Restaurant Menu ðŸ½ï¸**  
   - You pick "Pizza" or "Burger" from the menu, and the kitchen (factory) prepares it for you.  
   - You donâ€™t need to know how itâ€™s made, just what you want.  
   - **Factory Role:** It takes an input (your order) and provides the correct dish without exposing the cooking process.  

### 4ï¸âƒ£ **Bank Account Creation ðŸ¦**  
   - You request a "Savings" or "Checking" account, and the bank (factory) sets up the right type.  
   - You donâ€™t manually configure itâ€”the bank handles the process.  
   - **Factory Role:** It ensures the correct account type is created based on requirements.  

Each of these examples follows the **Factory Pattern** principle: **You request something, the factory handles the creation, and you receive the correct object without worrying about how it's built.** ðŸš€

## 5. Which programming principles (e.g., SOLID, DRY) does this pattern embody?
â€œÐ­Ð½Ñ Ð·Ð°Ð³Ð²Ð°Ñ€ ÑÐ¼Ð°Ñ€ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ñ‡Ð»Ð°Ð»Ñ‹Ð½ Ð·Ð°Ñ€Ñ‡Ð¼ÑƒÑƒÐ´Ñ‹Ð³ (Ð¶Ð¸ÑˆÑÑ Ð½ÑŒ, SOLID, DRY) Ð°Ð³ÑƒÑƒÐ»Ð´Ð°Ð³ Ð²Ñ?â€
The **Factory Pattern** embodies several key programming principles, particularly from the **SOLID** principles and other best practices like **DRY** and **Encapsulation**.  

### **1ï¸âƒ£ Single Responsibility Principle (SRP) âœ…**  
- **Problem:** If object creation logic is inside multiple places in the code, it violates SRP.  
- **Factory Solution:** Moves the creation logic to a dedicated class, keeping object creation **separate** from business logic.  

### **2ï¸âƒ£ Open/Closed Principle (OCP) âœ…**  
- **Problem:** If new object types require modifying existing code, the system is not open for extension.  
- **Factory Solution:** New classes can be introduced **without modifying existing client code**, making it open for extension but closed for modification.  

### **3ï¸âƒ£ Dependency Inversion Principle (DIP) âœ…**  
- **Problem:** If a class directly depends on concrete implementations, it makes changes harder.  
- **Factory Solution:** The client code depends on an **interface** or **abstract class**, not concrete classes, making the system **more flexible**.  

### **4ï¸âƒ£ DRY (Donâ€™t Repeat Yourself) âœ…**  
- **Problem:** Repeating object creation logic across multiple places leads to duplication.  
- **Factory Solution:** Centralizes object creation in one place, **reducing redundancy**.  

### **5ï¸âƒ£ Encapsulation âœ…**  
- **Problem:** If object creation logic is exposed, it can become complex and hard to manage.  
- **Factory Solution:** Hides complex instantiation details, simplifying object creation for the client.  

### **In Short:**  
The Factory Pattern **promotes clean, maintainable, and scalable code** by following SOLID principles, reducing redundancy, and improving flexibility in object creation. ðŸš€


### Python code
```python
from abc import ABC, abstractmethod

# Step 1: Create an abstract product class
class Product(ABC):
    @abstractmethod
    def operation(self):
        pass

# Step 2: Create concrete product classes
class ConcreteProductA(Product):
    def operation(self):
        return "ConcreteProductA operation executed."

class ConcreteProductB(Product):
    def operation(self):
        return "ConcreteProductB operation executed."

# Step 3: Create an abstract creator class
class Creator(ABC):
    @abstractmethod
    def factory_method(self) -> Product:
        pass
    
    def some_operation(self):
        product = self.factory_method()
        return f"Creator: {product.operation()}"

# Step 4: Create concrete creator classes
class ConcreteCreatorA(Creator):
    def factory_method(self) -> Product:
        return ConcreteProductA()

class ConcreteCreatorB(Creator):
    def factory_method(self) -> Product:
        return ConcreteProductB()

# Step 5: Client code
def client_code(creator: Creator):
    print(creator.some_operation())

if __name__ == "__main__":
    print("Testing ConcreteCreatorA:")
    client_code(ConcreteCreatorA())
    
    print("\nTesting ConcreteCreatorB:")
    client_code(ConcreteCreatorB())

```




```python
from abc import ABC, abstractmethod

# Step 1: Create an abstract shape class
class Shape(ABC):
    @abstractmethod
    def draw(self):
        pass

# Step 2: Create concrete shape classes
class Circle(Shape):
    def draw(self):
        return "Drawing a Circle."

class Square(Shape):
    def draw(self):
        return "Drawing a Square."

class Rectangle(Shape):
    def draw(self):
        return "Drawing a Rectangle."

# Step 3: Create an abstract creator class
class ShapeFactory(ABC):
    @abstractmethod
    def create_shape(self) -> Shape:
        pass
    
    def get_shape(self):
        shape = self.create_shape()
        return f"Factory: {shape.draw()}"

# Step 4: Create concrete shape factories
class CircleFactory(ShapeFactory):
    def create_shape(self) -> Shape:
        return Circle()

class SquareFactory(ShapeFactory):
    def create_shape(self) -> Shape:
        return Square()

class RectangleFactory(ShapeFactory):
    def create_shape(self) -> Shape:
        return Rectangle()

# Step 5: Client code
def client_code(factory: ShapeFactory):
    print(factory.get_shape())

if __name__ == "__main__":
    print("Testing CircleFactory:")
    client_code(CircleFactory())
    
    print("\nTesting SquareFactory:")
    client_code(SquareFactory())
    
    print("\nTesting RectangleFactory:")
    client_code(RectangleFactory())

```