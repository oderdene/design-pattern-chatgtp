## 2. What is the primary intent of this pattern?
‚Äú–≠–Ω—ç –∑–∞–≥–≤–∞—Ä—ã–Ω “Ø–Ω–¥—Å—ç–Ω –∑–æ—Ä–∏–ª–≥–æ —é—É –≤—ç?‚Äù

The **primary intent** of the **Factory Pattern** is to **encapsulate object creation** and provide a way to create objects **without specifying their exact class**. 
‚ÄúFactory Pattern-–∏–π–Ω “Ø–Ω–¥—Å—ç–Ω –∑–æ—Ä–∏–ª–≥–æ –Ω—å –æ–±—ä–µ–∫—Ç “Ø“Ø—Å–≥—ç—Ö “Ø–π–ª —è–≤—Ü—ã–≥ –Ω—É—É—Ö (encapsulate) –±”©–≥”©”©–¥ —Ç—É—Ö–∞–π–Ω –æ–±—ä–µ–∫—Ç–∏–π–≥ —è–≥ —è–º–∞—Ä –∫–ª–∞—Å—Å–∞–∞—Å “Ø“Ø—Å–≥—ç–∂ –±–∞–π–≥–∞–∞–≥ –∑–∞–∞—Ö–≥“Ø–π–≥—ç—ç—Ä “Ø“Ø—Å–≥—ç—Ö –∞—Ä–≥–∞ –∑–∞–º—ã–≥ —Ö–∞–Ω–≥–∞—Ö —è–≤–¥–∞–ª —é–º.‚Äù

### **Key Goals:**  
1. **Encapsulation of Object Creation** ‚Üí The factory handles object creation logic in one place.  
2. **Loose Coupling** ‚Üí The client code depends on an interface or abstract class, not concrete implementations.  
3. **Easier Maintenance & Scalability** ‚Üí Adding new object types doesn‚Äôt require modifying existing code.  
4. **Improved Code Reusability** ‚Üí The same factory can be used to create multiple object types.  

### **Simple Analogy:**  
Instead of manually assembling a car every time (direct object creation), you go to a **car factory** that builds the right model for you based on your request. üöó

## 3. Is this pattern categorized as creational, structural, or behavioral? Why?
The **Factory Pattern** is categorized as a **Creational** design pattern.  

### **Why?**  
- It focuses on **how objects are created**.  
- Instead of directly instantiating objects using `new`, it provides a controlled way to create them.  
- It ensures that object creation is **centralized, flexible, and reusable**, which is the main goal of creational patterns.  

### **Comparison with Other Categories:**  
- **Structural Patterns** ‚Üí Focus on organizing relationships between classes (e.g., Adapter, Decorator). –∫–ª–∞—Å—Å—É—É–¥—ã–Ω —Ö–æ–æ—Ä–æ–Ω–¥—ã–Ω —Ö–∞—Ä–∏–ª—Ü–∞–∞–≥ –∑–æ—Ö–∏–æ–Ω –±–∞–π–≥—É—É–ª–∞—Ö–∞–¥
- **Behavioral Patterns** ‚Üí Focus on communication between objects (e.g., Strategy, Observer). –æ–±—ä–µ–∫—Ç—É—É–¥—ã–Ω —Ö–æ–æ—Ä–æ–Ω–¥—ã–Ω —Ö–∞—Ä–∏–ª—Ü–∞–∞–Ω–¥

Since the Factory Pattern is all about **creating objects efficiently**, it belongs to the **Creational** category. üè≠


## 4. What are some real-world analogies for this pattern?

Here are some **real-world analogies** for the **Factory Pattern**:  

### 1Ô∏è‚É£ **Coffee Machine ‚òï**  
   - Instead of manually mixing coffee, milk, and sugar every time, you press a button for "Espresso" or "Cappuccino."  
   - The machine (factory) decides how to **prepare** and **deliver** the right drink.  
   - **Factory Role:** It hides the complex process and provides the correct coffee based on your request.  

### 2Ô∏è‚É£ **Car Factory üöó**  
   - You order a "Sedan" or "SUV," and the factory builds the right model.  
   - You don‚Äôt assemble it yourself‚Äîthe factory ensures you get the correct car.  
   - **Factory Role:** It abstracts away the manufacturing details and delivers the correct vehicle.  

### 3Ô∏è‚É£ **Restaurant Menu üçΩÔ∏è**  
   - You pick "Pizza" or "Burger" from the menu, and the kitchen (factory) prepares it for you.  
   - You don‚Äôt need to know how it‚Äôs made, just what you want.  
   - **Factory Role:** It takes an input (your order) and provides the correct dish without exposing the cooking process.  

### 4Ô∏è‚É£ **Bank Account Creation üè¶**  
   - You request a "Savings" or "Checking" account, and the bank (factory) sets up the right type.  
   - You don‚Äôt manually configure it‚Äîthe bank handles the process.  
   - **Factory Role:** It ensures the correct account type is created based on requirements.  

Each of these examples follows the **Factory Pattern** principle: **You request something, the factory handles the creation, and you receive the correct object without worrying about how it's built.** üöÄ

## 5. Which programming principles (e.g., SOLID, DRY) does this pattern embody?
‚Äú–≠–Ω—ç –∑–∞–≥–≤–∞—Ä —è–º–∞—Ä –ø—Ä–æ–≥—Ä–∞–º—á–ª–∞–ª—ã–Ω –∑–∞—Ä—á–º—É—É–¥—ã–≥ (–∂–∏—à—ç—ç –Ω—å, SOLID, DRY) –∞–≥—É—É–ª–¥–∞–≥ –≤—ç?‚Äù
The **Factory Pattern** embodies several key programming principles, particularly from the **SOLID** principles and other best practices like **DRY** and **Encapsulation**.  

### **1Ô∏è‚É£ Single Responsibility Principle (SRP) ‚úÖ**  
- **Problem:** If object creation logic is inside multiple places in the code, it violates SRP.  
- **Factory Solution:** Moves the creation logic to a dedicated class, keeping object creation **separate** from business logic.  

### **2Ô∏è‚É£ Open/Closed Principle (OCP) ‚úÖ**  
- **Problem:** If new object types require modifying existing code, the system is not open for extension.  
- **Factory Solution:** New classes can be introduced **without modifying existing client code**, making it open for extension but closed for modification.  

### **3Ô∏è‚É£ Dependency Inversion Principle (DIP) ‚úÖ**  
- **Problem:** If a class directly depends on concrete implementations, it makes changes harder.  
- **Factory Solution:** The client code depends on an **interface** or **abstract class**, not concrete classes, making the system **more flexible**.  

### **4Ô∏è‚É£ DRY (Don‚Äôt Repeat Yourself) ‚úÖ**  
- **Problem:** Repeating object creation logic across multiple places leads to duplication.  
- **Factory Solution:** Centralizes object creation in one place, **reducing redundancy**.  

### **5Ô∏è‚É£ Encapsulation ‚úÖ**  
- **Problem:** If object creation logic is exposed, it can become complex and hard to manage.  
- **Factory Solution:** Hides complex instantiation details, simplifying object creation for the client.  

### **In Short:**  
The Factory Pattern **promotes clean, maintainable, and scalable code** by following SOLID principles, reducing redundancy, and improving flexibility in object creation. üöÄ