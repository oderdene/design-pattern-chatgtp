## 20.	What are the most common pitfalls when using this pattern?


### **Common Pitfalls When Using the Factory Design Pattern 🚨**  

While the **Factory Design Pattern** is useful, it can lead to **several pitfalls** if not implemented properly. Let’s explore the most common mistakes and how to avoid them.  

---

## **1️⃣ Overusing the Factory Pattern (Unnecessary Complexity)**
### **🚨 Problem:**  
- **Not every object needs a factory.**  
- If the object creation logic is **simple**, a factory **adds unnecessary complexity**.  

🔹 **Bad Example: Unnecessary Factory**  
```java
class LoggerFactory {
    public static Logger getLogger() {
        return new Logger();  // Factory is redundant
    }
}

// Client code
Logger logger = LoggerFactory.getLogger();
```
🚨 **Issue:** Just use `new Logger();` instead.  

✅ **Better Approach:**  
```java
Logger logger = new Logger();  // No need for a factory
```
**🟢 Fix:** Use the Factory **only when object creation is complex or involves dependencies.**  

---

## **2️⃣ Violating Open/Closed Principle (OCP)**
### **🚨 Problem:**  
- A poorly designed factory requires **modifications** every time a new type is added.  
- This **violates the Open/Closed Principle (OCP)** because existing code must change.  

🔹 **Bad Example: Hardcoded Factory (Violates OCP)**  
```java
class ShapeFactory {
    public static Shape createShape(String type) {
        if (type.equalsIgnoreCase("circle")) return new Circle();
        if (type.equalsIgnoreCase("square")) return new Square();
        return null;
    }
}
```
🚨 **Issue:** Adding a new shape (e.g., `Triangle`) requires **modifying this method**, which breaks OCP.  

✅ **Better Approach: Registry-Based Factory (Extensible)**  
```java
class ShapeFactory {
    private static final Map<String, Supplier<Shape>> registeredShapes = new HashMap<>();

    public static void registerShape(String name, Supplier<Shape> supplier) {
        registeredShapes.put(name.toLowerCase(), supplier);
    }

    public static Shape createShape(String type) {
        Supplier<Shape> shape = registeredShapes.get(type.toLowerCase());
        if (shape != null) return shape.get();
        throw new IllegalArgumentException("Unknown shape type");
    }
}

// Register new shapes dynamically
ShapeFactory.registerShape("circle", Circle::new);
ShapeFactory.registerShape("square", Square::new);
ShapeFactory.registerShape("triangle", Triangle::new);
```
**🟢 Fix:** **Now, adding a new shape doesn’t require modifying the factory.**

---

## **3️⃣ Making the Factory Itself Too Complex**
### **🚨 Problem:**  
- Some developers **overcomplicate** factory classes, making them hard to maintain.  
- Factories should **only be responsible for object creation**, not **business logic**.  

🔹 **Bad Example: Overloaded Factory**
```java
class UserFactory {
    public static User createUser(String type) {
        if (type.equals("admin")) {
            User user = new AdminUser();
            user.setupPermissions();
            user.sendWelcomeEmail();
            return user;
        }
        if (type.equals("guest")) {
            User user = new GuestUser();
            user.setupPermissions();
            return user;
        }
        return null;
    }
}
```
🚨 **Issue:**  
- The factory **mixes object creation and business logic** (e.g., setting permissions, sending emails).  
- This **violates the Single Responsibility Principle (SRP)**.

✅ **Better Approach: Keep Factory Simple**
```java
class UserFactory {
    public static User createUser(String type) {
        return switch (type.toLowerCase()) {
            case "admin" -> new AdminUser();
            case "guest" -> new GuestUser();
            default -> throw new IllegalArgumentException("Unknown user type");
        };
    }
}
```
**🟢 Fix:** Move **business logic** (e.g., setting permissions) to **another class/service**.

---

## **4️⃣ Factory Pattern Hurting Performance (Object Creation Overhead)**
### **🚨 Problem:**  
- If the factory **always creates new objects**, it can lead to **performance issues**.  
- This is problematic for **expensive objects** like database connections or network clients.  

🔹 **Bad Example: Factory Creating a New Object Every Time**
```java
class DatabaseConnectionFactory {
    public static DatabaseConnection getConnection() {
        return new DatabaseConnection();  // Creates a new instance every time
    }
}
```
🚨 **Issue:** Causes **excessive object creation** and increases **Garbage Collection (GC) overhead**.

✅ **Better Approach: Use Object Pooling (Reuse Objects)**
```java
import java.util.concurrent.*;

class ConnectionFactory {
    private static BlockingQueue<DatabaseConnection> pool = new LinkedBlockingQueue<>(5);

    static {
        for (int i = 0; i < 5; i++) {
            pool.add(new DatabaseConnection());
        }
    }

    public static DatabaseConnection getConnection() throws InterruptedException {
        return pool.take();  // Get from pool
    }

    public static void returnConnection(DatabaseConnection conn) {
        pool.offer(conn);  // Return to pool
    }
}
```
**🟢 Fix:** **Now, connections are reused instead of created repeatedly.**  

---

## **5️⃣ Making the Factory Too Rigid**
### **🚨 Problem:**  
- Factories often assume **fixed configurations**, making them **hard to modify later**.  
- Clients might need **more control over object configuration**.  

🔹 **Bad Example: Rigid Factory (No Customization)**
```java
class CarFactory {
    public static Car createCar(String type) {
        if (type.equalsIgnoreCase("SUV")) return new Car("V8", "Black");
        if (type.equalsIgnoreCase("Sedan")) return new Car("V6", "White");
        return null;
    }
}
```
🚨 **Issue:** What if the user wants a **custom color or engine type**?

✅ **Better Approach: Use Builder Pattern for Customization**
```java
class Car {
    private String engine;
    private String color;

    private Car(CarBuilder builder) {
        this.engine = builder.engine;
        this.color = builder.color;
    }

    public static class CarBuilder {
        private String engine;
        private String color;

        public CarBuilder setEngine(String engine) { this.engine = engine; return this; }
        public CarBuilder setColor(String color) { this.color = color; return this; }
        public Car build() { return new Car(this); }
    }
}

class CarFactory {
    public static Car.CarBuilder createCar(String type) {
        return switch (type.toLowerCase()) {
            case "suv" -> new Car.CarBuilder().setEngine("V8");
            case "sedan" -> new Car.CarBuilder().setEngine("V6");
            default -> throw new IllegalArgumentException("Unknown car type");
        };
    }
}

// Client can customize car
Car myCar = CarFactory.createCar("SUV").setColor("Red").build();
```
**🟢 Fix:** Factory provides a **Builder**, allowing **flexibility**.

---

## **🚀 Summary: Most Common Factory Pattern Mistakes**
| **Pitfall** | **Problem** | **Fix** |
|------------|------------|---------|
| **Overusing Factories** | Factory adds unnecessary complexity | Use only when object creation is complex |
| **Violating Open/Closed Principle (OCP)** | Factory requires modification for new types | Use a **Registry-Based Factory** |
| **Factory Doing Too Much** | Mixing object creation & business logic | Keep factory **focused on creation** |
| **Performance Issues** | Too many objects created | Use **object pooling** |
| **Rigid Factories** | No flexibility for customization | Use **Builder Pattern** |

---

## **🎯 Final Thoughts**
✅ **Use Factory when needed, but don’t overuse it.**  
✅ **Keep it simple and avoid mixing business logic.**  
✅ **Optimize object creation for performance.**  
✅ **Make factories flexible and extensible.**  

Would you like a **real-world refactoring example** of a bad factory to a better one? 🚀