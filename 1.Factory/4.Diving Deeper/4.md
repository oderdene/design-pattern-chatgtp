## 19.	How does this pattern evolve with changes in requirements?
Энэ загвар шаардлагууд өөрчлөгдөх үед хэрхэн хөгжиж, дасан зохицдог вэ?

### **How the Factory Design Pattern Evolves with Changing Requirements 🚀**  

The **Factory Design Pattern** is designed to be **flexible and extensible**, making it **adaptable** to evolving requirements. However, as requirements change, the factory itself may need modifications. Here’s how it evolves:

---

## **1️⃣ When New Product Types Are Introduced**  
### **🔹 Problem:**  
- Initially, a factory might handle only a **few product types**, but later **new types** need to be supported.  
- **Hardcoding new types in a factory breaks the Open/Closed Principle (OCP).**  

### **🛠 Evolution: Use a Registry-Based Factory**  
Instead of modifying the factory each time a new class is added, use **dynamic registration**.

🔹 **Before (Hardcoded Factory - Difficult to Extend)**
```java
class ShapeFactory {
    public static Shape createShape(String type) {
        return switch (type.toLowerCase()) {
            case "circle" -> new Circle();
            case "square" -> new Square();
            default -> throw new IllegalArgumentException("Unknown shape type");
        };
    }
}
```
🚨 **Problem:** Every time a new shape (e.g., `Triangle`) is introduced, the factory needs modification.

🔹 **After (Registry-Based Factory - Easily Extensible)**
```java
class ShapeFactory {
    private static final Map<String, Supplier<Shape>> registeredShapes = new HashMap<>();

    public static void registerShape(String name, Supplier<Shape> supplier) {
        registeredShapes.put(name, supplier);
    }

    public static Shape createShape(String type) {
        Supplier<Shape> shape = registeredShapes.get(type.toLowerCase());
        if (shape != null) return shape.get();
        throw new IllegalArgumentException("Unknown shape type");
    }
}

// Register new shapes dynamically
ShapeFactory.registerShape("circle", Circle::new);
ShapeFactory.registerShape("square", Square::new);
ShapeFactory.registerShape("triangle", Triangle::new);
```
✅ **Factory is now open for extension without modification!**  

---

## **2️⃣ When Object Creation Becomes Expensive**
### **🔹 Problem:**  
- Some objects become **expensive to create** as the system scales.  
- Frequent object creation leads to **performance issues**.  

### **🛠 Evolution: Use Object Pooling**  
Instead of creating new objects every time, **reuse existing ones**.

🔹 **Before (Inefficient - Creates a New Object Every Time)**
```java
class ConnectionFactory {
    public static DatabaseConnection getConnection() {
        return new DatabaseConnection();  // Creates a new object each time
    }
}
```
🔹 **After (Optimized - Uses Object Pooling)**
```java
import java.util.concurrent.*;

class ConnectionFactory {
    private static BlockingQueue<DatabaseConnection> pool = new LinkedBlockingQueue<>(5);

    static {
        for (int i = 0; i < 5; i++) {
            pool.add(new DatabaseConnection());
        }
    }

    public static DatabaseConnection getConnection() throws InterruptedException {
        return pool.take();  // Get an existing connection from the pool
    }

    public static void returnConnection(DatabaseConnection conn) {
        pool.offer(conn);  // Return the connection back to the pool
    }
}
```
✅ **Factory now improves performance by reusing objects instead of creating new ones.**

---

## **3️⃣ When Object Configuration Needs More Flexibility**
### **🔹 Problem:**  
- Initially, objects may be created with **default values**, but later requirements demand **custom configurations**.  
- The factory must support **dynamic parameters**.  

### **🛠 Evolution: Use a Builder Pattern Alongside the Factory**  
🔹 **Before (Rigid Factory with Fixed Configurations)**
```java
class CarFactory {
    public static Car createCar(String type) {
        if (type.equalsIgnoreCase("SUV")) return new Car("V8", 4, "Black");
        if (type.equalsIgnoreCase("Sedan")) return new Car("V6", 4, "White");
        throw new IllegalArgumentException("Unknown car type");
    }
}
```
🚨 **Problem:** What if users want to specify a custom color or engine type?

🔹 **After (Flexible Factory + Builder)**
```java
class Car {
    private String engine;
    private int wheels;
    private String color;

    private Car(CarBuilder builder) {
        this.engine = builder.engine;
        this.wheels = builder.wheels;
        this.color = builder.color;
    }

    public static class CarBuilder {
        private String engine;
        private int wheels;
        private String color;

        public CarBuilder setEngine(String engine) { this.engine = engine; return this; }
        public CarBuilder setWheels(int wheels) { this.wheels = wheels; return this; }
        public CarBuilder setColor(String color) { this.color = color; return this; }
        public Car build() { return new Car(this); }
    }
}

// Factory now returns a builder
class CarFactory {
    public static Car.CarBuilder createCar(String type) {
        if (type.equalsIgnoreCase("SUV")) return new Car.CarBuilder().setEngine("V8").setWheels(4);
        if (type.equalsIgnoreCase("Sedan")) return new Car.CarBuilder().setEngine("V6").setWheels(4);
        throw new IllegalArgumentException("Unknown car type");
    }
}

// Client can customize the car
Car myCar = CarFactory.createCar("SUV").setColor("Red").build();
```
✅ **Factory is now more flexible and allows customization.**

---

## **4️⃣ When Factories Need to Manage Families of Related Objects**
### **🔹 Problem:**  
- If the system grows, **multiple related objects** may need to be created together.  
- A **regular Factory** doesn’t work well when there are **groups of related objects** (e.g., Windows UI components vs. Mac UI components).  

### **🛠 Evolution: Use Abstract Factory Pattern**
🔹 **Before (Multiple Factories for Related Objects)**
```java
class ButtonFactory {
    public static Button createButton(String os) {
        if (os.equalsIgnoreCase("Windows")) return new WindowsButton();
        if (os.equalsIgnoreCase("Mac")) return new MacButton();
        throw new IllegalArgumentException("Unknown OS");
    }
}

class CheckboxFactory {
    public static Checkbox createCheckbox(String os) {
        if (os.equalsIgnoreCase("Windows")) return new WindowsCheckbox();
        if (os.equalsIgnoreCase("Mac")) return new MacCheckbox();
        throw new IllegalArgumentException("Unknown OS");
    }
}
```
🚨 **Problem:** If new UI components (e.g., `Slider`, `Dropdown`) are added, multiple factories need updates.

🔹 **After (Using Abstract Factory)**
```java
// Abstract Factory
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Concrete Factories for Windows and Mac
class WindowsFactory implements GUIFactory {
    public Button createButton() { return new WindowsButton(); }
    public Checkbox createCheckbox() { return new WindowsCheckbox(); }
}

class MacFactory implements GUIFactory {
    public Button createButton() { return new MacButton(); }
    public Checkbox createCheckbox() { return new MacCheckbox(); }
}

// Client Code
GUIFactory factory = new WindowsFactory();  // Dynamically choose factory
Button button = factory.createButton();
Checkbox checkbox = factory.createCheckbox();
```
✅ **Now, adding new UI components (e.g., `Dropdown`) only requires changes inside the factory classes.**

---

## **🚀 Summary: How Factory Evolves with Changing Requirements**
| **Requirement Change** | **Evolution of Factory** | **Pattern Used** |
|----------------|--------------------|----------------|
| **New product types** | Use a **Registry-Based Factory** | Dynamic Factory |
| **Object creation becomes expensive** | Use **Object Pooling** | Factory + Object Pool |
| **Need for configurable objects** | Use **Builder Pattern** | Factory + Builder |
| **Managing related objects** | Use **Abstract Factory** | Abstract Factory |

---

## **Final Thoughts**
✅ **Factory Pattern evolves as applications scale** by integrating **more advanced patterns**.  
✅ **Using techniques like Object Pooling, Builder, and Abstract Factory makes factories more efficient and maintainable.**  
✅ **The goal is to minimize changes to existing code while allowing new functionality to be added easily.**  

Would you like help refactoring an existing factory to be more **scalable and maintainable**? 🚀