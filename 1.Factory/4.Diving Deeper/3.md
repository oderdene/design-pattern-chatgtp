## 18.	How does this pattern behave in concurrent or multi-threaded environments?
“Энэ загвар зэрэгцээ (concurrent) эсвэл олон урсгалт (multi-threaded) орчинд хэрхэн ажилладаг вэ?”

### **Factory Pattern in Concurrent or Multi-Threaded Environments** ⚙️🚀

The **Factory Design Pattern** is commonly used in multi-threaded applications, but **it introduces concurrency challenges** that must be carefully handled. Let's explore how it behaves in such environments and how to mitigate potential issues.

---

## **1️⃣ Potential Issues of Factory Pattern in Multi-Threaded Environments**
### **🔴 Issue 1: Race Conditions in Singleton Factories**
- If a factory method **creates shared resources (e.g., Singleton objects)**, **race conditions** may occur.
- Two threads may **simultaneously check if an instance exists** and create **duplicate objects**, violating the Singleton pattern.

🔹 **Example: Unsafe Singleton Factory (Thread-Unsafe)**
```java
class SingletonFactory {
    private static DatabaseConnection instance;

    public static DatabaseConnection getInstance() {
        if (instance == null) {  // 🚨 Race condition if two threads access this at the same time
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
```
🚨 **Problem:** Multiple threads might create multiple instances, leading to **unexpected behavior**.

✅ **Solution: Use Double-Checked Locking**
```java
class SingletonFactory {
    private static volatile DatabaseConnection instance;

    public static DatabaseConnection getInstance() {
        if (instance == null) {  // First check (without locking)
            synchronized (SingletonFactory.class) {
                if (instance == null) {  // Second check (inside lock)
                    instance = new DatabaseConnection();
                }
            }
        }
        return instance;
    }
}
```
🔹 **Why This Works?**  
- **First check (`if (instance == null)`)** avoids unnecessary locking (performance boost).
- **Second check (inside `synchronized`)** ensures only one instance is created.

---

### **🔴 Issue 2: Thread Contention in Factory Methods**
- If multiple threads frequently **call a factory method**, they might **contend for shared resources** (e.g., expensive database connections, file handles).
- This can lead to **performance bottlenecks**.

🔹 **Example: Factory with High Contention**
```java
class ConnectionFactory {
    private static List<DatabaseConnection> pool = new ArrayList<>();

    public static synchronized DatabaseConnection getConnection() {
        if (pool.isEmpty()) {
            return new DatabaseConnection();  // 🚨 Every thread waits for this lock
        }
        return pool.remove(0);
    }
}
```
🚨 **Problem:** The entire method is `synchronized`, meaning **only one thread** can access it at a time.

✅ **Solution: Use a Concurrent Queue**
```java
import java.util.concurrent.*;

class ConnectionFactory {
    private static BlockingQueue<DatabaseConnection> pool = new LinkedBlockingQueue<>(10);

    static {
        for (int i = 0; i < 10; i++) {
            pool.add(new DatabaseConnection());
        }
    }

    public static DatabaseConnection getConnection() throws InterruptedException {
        return pool.take();  // Thread-safe pool access
    }

    public static void returnConnection(DatabaseConnection conn) {
        pool.offer(conn);
    }
}
```
🔹 **Why This Works?**  
- Uses `BlockingQueue`, which is **thread-safe**.
- Allows multiple threads to **get and return objects concurrently**.

---

### **🔴 Issue 3: Factory Methods Using Reflection**
- Some factories use **reflection (`Class.forName()`)** to create objects dynamically.
- Reflection **is not thread-safe**, and its **performance is poor in high-concurrency environments**.

🔹 **Example: Reflection-Based Factory (Not Recommended)**
```java
class ReflectionFactory {
    public static Object createInstance(String className) throws Exception {
        return Class.forName(className).getDeclaredConstructor().newInstance();
    }
}
```
🚨 **Problem:**  
- **Reflection is slow** compared to direct instantiation.  
- **Not thread-safe** if multiple threads modify the class loader.  

✅ **Solution: Use Pre-Registered Class Mappings**
```java
class RegisteredFactory {
    private static final Map<String, Supplier<Shape>> registeredShapes = new ConcurrentHashMap<>();

    static {
        registeredShapes.put("circle", Circle::new);
        registeredShapes.put("square", Square::new);
    }

    public static Shape createShape(String type) {
        return registeredShapes.get(type).get();  // Fast and thread-safe
    }
}
```
🔹 **Why This Works?**  
- **Avoids slow reflection**.  
- **ConcurrentHashMap** ensures thread safety.

---

## **2️⃣ Best Practices for Using Factory Pattern in Multi-Threaded Applications**
| **Problem** | **Solution** | **Implementation** |
|------------|-------------|-----------------|
| **Race conditions in Singleton factories** | **Double-Checked Locking** | Use `volatile` and `synchronized` blocks |
| **Thread contention in factory methods** | **Use concurrent collections** | `BlockingQueue` for object pooling |
| **Reflection-based instantiation is slow** | **Use class mappings instead** | `ConcurrentHashMap` to store pre-registered classes |
| **Factories returning shared resources** | **Use object pooling** | Avoid creating expensive objects repeatedly |
| **Global state changes in factories** | **Immutable factory objects** | Keep factory configurations read-only |

---

## **3️⃣ Real-World Example: Multi-Threaded Factory in Java**
Let's implement a **thread-safe object pool using a factory**.

### **🔹 Scenario: Managing Database Connections in a Multi-Threaded Environment**
- Multiple threads request **database connections**.
- The factory **reuses objects instead of creating new ones**.
- Uses **`BlockingQueue`** to ensure **thread safety**.

### **🔹 Implementation**
```java
import java.util.concurrent.*;

class DatabaseConnection {
    public DatabaseConnection() {
        System.out.println("Database Connection Created");
    }
}

class ConnectionFactory {
    private static BlockingQueue<DatabaseConnection> pool = new LinkedBlockingQueue<>(5);

    static {
        for (int i = 0; i < 5; i++) {
            pool.add(new DatabaseConnection());
        }
    }

    public static DatabaseConnection getConnection() throws InterruptedException {
        return pool.take();  // Thread-safe access
    }

    public static void returnConnection(DatabaseConnection conn) {
        pool.offer(conn);
    }
}

public class MultiThreadedFactoryExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        
        for (int i = 0; i < 10; i++) {
            executor.execute(() -> {
                try {
                    DatabaseConnection conn = ConnectionFactory.getConnection();
                    System.out.println(Thread.currentThread().getName() + " got a connection");
                    Thread.sleep(1000);  // Simulating DB work
                    ConnectionFactory.returnConnection(conn);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }

        executor.shutdown();
    }
}
```
### **🔹 Expected Output**
```
Database Connection Created
Database Connection Created
Database Connection Created
Database Connection Created
Database Connection Created
pool-1-thread-1 got a connection
pool-1-thread-2 got a connection
...
```
🔹 **Why This Works?**  
✅ Uses **object pooling** for **efficient connection reuse**.  
✅ Prevents **race conditions** using **thread-safe `BlockingQueue`**.  
✅ Handles **concurrent access properly**.

---

## **🚀 Final Thoughts**
✅ The **Factory Pattern works well in multi-threaded environments** but must be **carefully implemented**.  
✅ Use **Double-Checked Locking** for **Singleton Factories**.  
✅ Use **Concurrent Collections (`BlockingQueue`, `ConcurrentHashMap`)** to handle **object pooling**.  
✅ Avoid **reflection-based instantiation** in high-performance systems.  

Would you like a **benchmark comparison of different factory approaches in multi-threading**? 🚀