## 22.	Can I refactor an existing project to use this pattern?


### **Refactoring an Existing Project to Use the Factory Pattern 🚀**  

Yes! You can refactor an existing project to use the **Factory Design Pattern**, and it’s often beneficial for improving **maintainability, scalability, and flexibility**. Let’s go step by step:

---

## **🛠 Steps to Refactor an Existing Project to Use Factory Pattern**
1️⃣ **Identify where object creation is repetitive or tightly coupled.**  
2️⃣ **Extract object creation logic into a factory class.**  
3️⃣ **Use interfaces or abstract classes (if applicable).**  
4️⃣ **Replace direct instantiation (`new`) with factory methods.**  
5️⃣ **Ensure flexibility for adding new types without modifying existing code.**  
6️⃣ **Optimize the factory for performance (if needed).**  

---

## **🔍 Step-by-Step Example: Refactoring a Notification System**  
Imagine you have an **existing system** where different types of notifications (Email, SMS, Push) are handled **manually**.

### **🔴 Before Refactoring (Tightly Coupled Code)**
```java
class NotificationService {
    public void sendNotification(String type, String message) {
        if (type.equalsIgnoreCase("email")) {
            EmailSender sender = new EmailSender();
            sender.send(message);
        } else if (type.equalsIgnoreCase("sms")) {
            SMSSender sender = new SMSSender();
            sender.send(message);
        } else if (type.equalsIgnoreCase("push")) {
            PushNotificationSender sender = new PushNotificationSender();
            sender.send(message);
        } else {
            throw new IllegalArgumentException("Invalid notification type");
        }
    }
}
```
### **🚨 Problems:**
❌ **Tightly coupled** → The `NotificationService` depends on **specific classes** (`EmailSender`, `SMSSender`, etc.).  
❌ **Difficult to extend** → Adding a new notification type (e.g., Slack) **requires modifying this class**.  
❌ **Code duplication** → Object creation logic is scattered across the codebase.  

---

## **🛠 Step 1: Extract Object Creation into a Factory**
We **move object creation** into a `NotificationFactory` class.

### **🟢 After Refactoring (Using Factory Pattern)**
```java
// Step 1: Create a common interface for notifications
interface NotificationSender {
    void send(String message);
}

// Step 2: Implement concrete classes
class EmailSender implements NotificationSender {
    public void send(String message) {
        System.out.println("Sending Email: " + message);
    }
}

class SMSSender implements NotificationSender {
    public void send(String message) {
        System.out.println("Sending SMS: " + message);
    }
}

class PushNotificationSender implements NotificationSender {
    public void send(String message) {
        System.out.println("Sending Push Notification: " + message);
    }
}

// Step 3: Implement the Factory
class NotificationFactory {
    public static NotificationSender getSender(String type) {
        return switch (type.toLowerCase()) {
            case "email" -> new EmailSender();
            case "sms" -> new SMSSender();
            case "push" -> new PushNotificationSender();
            default -> throw new IllegalArgumentException("Invalid notification type");
        };
    }
}

// Step 4: Modify the NotificationService to use the factory
class NotificationService {
    public void sendNotification(String type, String message) {
        NotificationSender sender = NotificationFactory.getSender(type);
        sender.send(message);
    }
}

// Step 5: Client Code
public class Main {
    public static void main(String[] args) {
        NotificationService service = new NotificationService();
        service.sendNotification("email", "Hello, this is an email!");
        service.sendNotification("sms", "Hello, this is an SMS!");
    }
}
```

---

## **✅ Benefits of This Refactoring**
| **Before Refactoring** ❌ | **After Refactoring** ✅ |
|------------------|------------------|
| Tightly coupled to specific classes | Uses **Factory Pattern**, **loosely coupled** |
| Hard to extend (requires modifying existing code) | **New notification types can be added easily** |
| Object creation logic is repeated | **Centralized object creation** in `NotificationFactory` |
| More error-prone | **Cleaner, more maintainable code** |

Now, if we **add a new notification type (e.g., Slack)**, we **don’t modify `NotificationService`**—we just extend the factory:

```java
class SlackSender implements NotificationSender {
    public void send(String message) {
        System.out.println("Sending Slack Message: " + message);
    }
}

// Register SlackSender in the factory
class NotificationFactory {
    public static NotificationSender getSender(String type) {
        return switch (type.toLowerCase()) {
            case "email" -> new EmailSender();
            case "sms" -> new SMSSender();
            case "push" -> new PushNotificationSender();
            case "slack" -> new SlackSender();
            default -> throw new IllegalArgumentException("Invalid notification type");
        };
    }
}
```
✅ **Adding a new notification type requires modifying only the factory, not the service or client code!**  

---

## **🛠 When Should You Refactor to Use the Factory Pattern?**
| **Scenario** | **Refactor to Factory?** |
|------------|----------------|
| **Object creation logic is duplicated in multiple places** | ✅ Yes |
| **Adding new object types requires modifying existing code** | ✅ Yes |
| **Objects have complex initialization logic** | ✅ Yes |
| **You need different object implementations based on runtime conditions** | ✅ Yes |
| **Simple objects with no variations** | ❌ No |
| **Only one concrete class is ever used** | ❌ No |

---

## **🚀 Advanced Factory Optimizations**
### **1️⃣ If Object Creation is Expensive → Use Object Pooling**
- If objects like **database connections, network clients, or threads** are created frequently, use **a factory with object pooling**.

```java
import java.util.concurrent.*;

class ConnectionFactory {
    private static BlockingQueue<DatabaseConnection> pool = new LinkedBlockingQueue<>(5);

    static {
        for (int i = 0; i < 5; i++) {
            pool.add(new DatabaseConnection());
        }
    }

    public static DatabaseConnection getConnection() throws InterruptedException {
        return pool.take();
    }

    public static void returnConnection(DatabaseConnection conn) {
        pool.offer(conn);
    }
}
```

---

### **2️⃣ If Object Configuration Needs More Flexibility → Combine Factory with Builder Pattern**
```java
class Car {
    private String engine;
    private String color;

    private Car(CarBuilder builder) {
        this.engine = builder.engine;
        this.color = builder.color;
    }

    public static class CarBuilder {
        private String engine;
        private String color;

        public CarBuilder setEngine(String engine) { this.engine = engine; return this; }
        public CarBuilder setColor(String color) { this.color = color; return this; }
        public Car build() { return new Car(this); }
    }
}

class CarFactory {
    public static Car.CarBuilder createCar(String type) {
        return switch (type.toLowerCase()) {
            case "suv" -> new Car.CarBuilder().setEngine("V8");
            case "sedan" -> new Car.CarBuilder().setEngine("V6");
            default -> throw new IllegalArgumentException("Unknown car type");
        };
    }
}

// Client can customize car
Car myCar = CarFactory.createCar("SUV").setColor("Red").build();
```

---

## **🎯 Final Thoughts**
✅ **Factory Pattern improves maintainability, flexibility, and scalability**.  
✅ **Refactoring helps remove tight coupling and duplicate object creation logic**.  
✅ **Factories should be simple, avoiding unnecessary complexity**.  

Would you like help **refactoring a specific part of your project** to use the Factory Pattern? 🚀