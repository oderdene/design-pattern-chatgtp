## 15.	Can this pattern be combined with others for complex solutions?

### **Yes! The Factory Pattern Can Be Combined with Other Patterns for Complex Solutions 🚀**  

The **Factory Design Pattern** is often used **alongside other design patterns** to build **scalable, flexible, and maintainable** systems. Here are some powerful combinations:

---

## **1️⃣ Factory + Singleton: Controlled Object Creation**
### **Use Case:** When you need a **single shared instance** but want a Factory to control access.

### **Example: Database Connection Pool**
- **Singleton ensures only one instance of the pool exists.**
- **Factory manages and provides connections to clients.**

🔹 **Implementation (Java)**
```java
class DatabaseConnection {
    private static DatabaseConnection instance;
    
    private DatabaseConnection() { 
        System.out.println("Database Connection Created"); 
    }

    public static DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}

// Factory to create and manage connection
class ConnectionFactory {
    public static DatabaseConnection getConnection() {
        return DatabaseConnection.getInstance();
    }
}

// Client
public class Main {
    public static void main(String[] args) {
        DatabaseConnection conn1 = ConnectionFactory.getConnection();
        DatabaseConnection conn2 = ConnectionFactory.getConnection();
        System.out.println(conn1 == conn2);  // Output: true (same instance)
    }
}
```
**🔹 Benefit:** **Factory manages object creation, Singleton ensures only one instance exists.**

---

## **2️⃣ Factory + Builder: When Objects Require Many Custom Parameters**
### **Use Case:**  
- The **Factory** is great for choosing **which class to create**.  
- The **Builder** is great for **constructing complex objects with multiple optional parameters**.

### **Example: Car Factory with Builder**
🔹 **Implementation (Java)**
```java
class Car {
    private String engine;
    private int wheels;
    private String color;

    private Car(CarBuilder builder) {
        this.engine = builder.engine;
        this.wheels = builder.wheels;
        this.color = builder.color;
    }

    // Builder Class
    public static class CarBuilder {
        private String engine;
        private int wheels;
        private String color;

        public CarBuilder setEngine(String engine) {
            this.engine = engine;
            return this;
        }

        public CarBuilder setWheels(int wheels) {
            this.wheels = wheels;
            return this;
        }

        public CarBuilder setColor(String color) {
            this.color = color;
            return this;
        }

        public Car build() {
            return new Car(this);
        }
    }
}

// Factory
class CarFactory {
    public static Car createCar(String type) {
        if (type.equalsIgnoreCase("SUV")) {
            return new Car.CarBuilder().setEngine("V8").setWheels(4).setColor("Black").build();
        } else if (type.equalsIgnoreCase("Sedan")) {
            return new Car.CarBuilder().setEngine("V6").setWheels(4).setColor("White").build();
        }
        throw new IllegalArgumentException("Unknown car type");
    }
}

// Client
public class Main {
    public static void main(String[] args) {
        Car suv = CarFactory.createCar("SUV");
    }
}
```
**🔹 Benefit:**  
- **Factory** decides which car type to create.  
- **Builder** constructs the car step by step.

---

## **3️⃣ Factory + Abstract Factory: For Complex Families of Objects**
### **Use Case:** When you need a Factory to create **related groups of objects** dynamically.

### **Example: GUI Toolkit (Windows vs. Mac)**
🔹 **Implementation (Java)**
```java
// Product Interfaces
interface Button { void render(); }
interface Checkbox { void render(); }

// Concrete Products for Windows
class WindowsButton implements Button { public void render() { System.out.println("Windows Button"); } }
class WindowsCheckbox implements Checkbox { public void render() { System.out.println("Windows Checkbox"); } }

// Concrete Products for Mac
class MacButton implements Button { public void render() { System.out.println("Mac Button"); } }
class MacCheckbox implements Checkbox { public void render() { System.out.println("Mac Checkbox"); } }

// Abstract Factory
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Concrete Factory for Windows
class WindowsFactory implements GUIFactory {
    public Button createButton() { return new WindowsButton(); }
    public Checkbox createCheckbox() { return new WindowsCheckbox(); }
}

// Concrete Factory for Mac
class MacFactory implements GUIFactory {
    public Button createButton() { return new MacButton(); }
    public Checkbox createCheckbox() { return new MacCheckbox(); }
}

// Client
public class Main {
    public static void main(String[] args) {
        GUIFactory factory = new WindowsFactory();  // Dynamically decide
        Button button = factory.createButton();
        Checkbox checkbox = factory.createCheckbox();
        button.render();
        checkbox.render();
    }
}
```
**🔹 Benefit:**  
- **Factory Method creates individual objects.**  
- **Abstract Factory groups related objects together dynamically.**  

---

## **4️⃣ Factory + Prototype: When Cloning is Required**
### **Use Case:** When object creation is expensive, **Factory provides a Prototype to clone instead of creating new instances.**

### **Example: Game Character Factory**
🔹 **Implementation (Java)**
```java
interface Character extends Cloneable {
    Character clone();
}

// Concrete Character
class Warrior implements Character {
    public Warrior() { System.out.println("Warrior Created"); }
    
    public Character clone() {
        return new Warrior(); // Cloning instead of new object
    }
}

// Factory that returns clones instead of new objects
class CharacterFactory {
    private static Character prototype = new Warrior();  // Store a prototype

    public static Character getCharacter() {
        return prototype.clone();
    }
}

// Client
public class Main {
    public static void main(String[] args) {
        Character char1 = CharacterFactory.getCharacter();  // Clones from prototype
        Character char2 = CharacterFactory.getCharacter();
    }
}
```
**🔹 Benefit:**  
- **Factory creates objects using cloning instead of instantiation, reducing memory usage.**  
- **Prototype is useful for large-scale object creation.**

---

## **5️⃣ Factory + Strategy: For Dynamic Behavior Switching**
### **Use Case:** When you need a Factory to **return different behaviors (strategies) at runtime**.

### **Example: Payment Processing System**
🔹 **Implementation (Java)**
```java
// Strategy Interface
interface PaymentStrategy {
    void pay(int amount);
}

// Concrete Strategies
class CreditCardPayment implements PaymentStrategy {
    public void pay(int amount) { System.out.println("Paid $" + amount + " with Credit Card"); }
}
class PayPalPayment implements PaymentStrategy {
    public void pay(int amount) { System.out.println("Paid $" + amount + " with PayPal"); }
}

// Factory for Strategy Selection
class PaymentFactory {
    public static PaymentStrategy getPaymentMethod(String type) {
        return switch (type.toLowerCase()) {
            case "creditcard" -> new CreditCardPayment();
            case "paypal" -> new PayPalPayment();
            default -> throw new IllegalArgumentException("Invalid payment type");
        };
    }
}

// Client
public class Main {
    public static void main(String[] args) {
        PaymentStrategy payment = PaymentFactory.getPaymentMethod("creditcard");
        payment.pay(100);
    }
}
```
**🔹 Benefit:**  
- **Factory decides which strategy to return.**  
- **Strategy defines behavior dynamically at runtime.**  

---

## **🚀 Conclusion**
The **Factory Pattern is a powerful tool** that can be **combined** with other design patterns to solve **complex software problems**.

| **Factory + ...** | **Use Case** |
|----------------|-----------|
| **Singleton** | Controlled object creation (e.g., Database connection pool) |
| **Builder** | When objects require many configurations (e.g., CarFactory) |
| **Abstract Factory** | Managing families of related objects (e.g., GUI Toolkit) |
| **Prototype** | Cloning instead of instantiation (e.g., Game Characters) |
| **Strategy** | Changing behavior dynamically (e.g., Payment Processing) |

Would you like me to expand on any of these combinations? 🚀