## 9. Are there alternative ways to implement the builder design pattern?
Yes, there are several **alternative ways** to implement the **Builder Design Pattern** in Java. Here are a few variations:

---

### **1. Using a Static Nested Class (Traditional Builder)**
âœ… **Most common implementation** (as shown earlier).  
ðŸ”¹ Uses a static nested class with method chaining.  
ðŸ”¹ Keeps the object immutable after creation.

```java
public class Computer {
    private final String CPU;
    private final String RAM;
    private final String storage;
    private final boolean hasGraphicsCard;

    private Computer(Builder builder) {
        this.CPU = builder.CPU;
        this.RAM = builder.RAM;
        this.storage = builder.storage;
        this.hasGraphicsCard = builder.hasGraphicsCard;
    }

    public static class Builder {
        private String CPU;
        private String RAM;
        private String storage;
        private boolean hasGraphicsCard;

        public Builder(String CPU, String RAM) {
            this.CPU = CPU;
            this.RAM = RAM;
        }

        public Builder setStorage(String storage) {
            this.storage = storage;
            return this;
        }

        public Builder setGraphicsCard(boolean hasGraphicsCard) {
            this.hasGraphicsCard = hasGraphicsCard;
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }
}
```

---

### **2. Using Lombok's `@Builder` Annotation**  
âœ… **Simplifies builder implementation** with **less boilerplate code**.  
ðŸ”¹ Requires **Lombok** dependency.  
ðŸ”¹ Eliminates the need for manually writing builder methods.  

```java
import lombok.Builder;
import lombok.ToString;

@Builder
@ToString
public class Computer {
    private String CPU;
    private String RAM;
    private String storage;
    private boolean hasGraphicsCard;
}

// Usage
public class Main {
    public static void main(String[] args) {
        Computer pc = Computer.builder()
                .CPU("AMD Ryzen 9")
                .RAM("32GB")
                .storage("1TB NVMe SSD")
                .hasGraphicsCard(true)
                .build();

        System.out.println(pc);
    }
}
```

---

### **3. Using Separate Builder Class (Non-Static Builder)**
âœ… **Good for when builder needs to extend an interface or abstract class.**  
ðŸ”¹ The builder is a separate class, **not nested inside the product class**.

```java
class Computer {
    private String CPU;
    private String RAM;
    private String storage;
    private boolean hasGraphicsCard;

    public Computer(String CPU, String RAM, String storage, boolean hasGraphicsCard) {
        this.CPU = CPU;
        this.RAM = RAM;
        this.storage = storage;
        this.hasGraphicsCard = hasGraphicsCard;
    }

    @Override
    public String toString() {
        return "Computer [CPU=" + CPU + ", RAM=" + RAM + ", Storage=" + storage + 
               ", GraphicsCard=" + hasGraphicsCard + "]";
    }
}

// Separate Builder Class
class ComputerBuilder {
    private String CPU;
    private String RAM;
    private String storage;
    private boolean hasGraphicsCard;

    public ComputerBuilder setCPU(String CPU) {
        this.CPU = CPU;
        return this;
    }

    public ComputerBuilder setRAM(String RAM) {
        this.RAM = RAM;
        return this;
    }

    public ComputerBuilder setStorage(String storage) {
        this.storage = storage;
        return this;
    }

    public ComputerBuilder setGraphicsCard(boolean hasGraphicsCard) {
        this.hasGraphicsCard = hasGraphicsCard;
        return this;
    }

    public Computer build() {
        return new Computer(CPU, RAM, storage, hasGraphicsCard);
    }
}

// Usage
public class Main {
    public static void main(String[] args) {
        Computer gamingPC = new ComputerBuilder()
                                .setCPU("Intel i9")
                                .setRAM("32GB")
                                .setStorage("1TB SSD")
                                .setGraphicsCard(true)
                                .build();
        System.out.println(gamingPC);
    }
}
```

---

### **4. Using Functional Interface (Lambda Builder)**
âœ… **Best for reducing boilerplate code using Java 8+ lambdas.**  
ðŸ”¹ Uses **consumer-based approach** for a cleaner syntax.

```java
import java.util.function.Consumer;

class Computer {
    private String CPU;
    private String RAM;
    private String storage;
    private boolean hasGraphicsCard;

    public Computer(Builder builder) {
        this.CPU = builder.CPU;
        this.RAM = builder.RAM;
        this.storage = builder.storage;
        this.hasGraphicsCard = builder.hasGraphicsCard;
    }

    public static class Builder {
        private String CPU;
        private String RAM;
        private String storage;
        private boolean hasGraphicsCard;

        public Builder with(Consumer<Builder> builderFunction) {
            builderFunction.accept(this);
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }

    @Override
    public String toString() {
        return "Computer [CPU=" + CPU + ", RAM=" + RAM + ", Storage=" + storage + 
               ", GraphicsCard=" + hasGraphicsCard + "]";
    }
}

// Usage
public class Main {
    public static void main(String[] args) {
        Computer pc = new Computer.Builder()
                .with(builder -> {
                    builder.CPU = "Intel i7";
                    builder.RAM = "16GB";
                    builder.storage = "512GB SSD";
                    builder.hasGraphicsCard = false;
                }).build();

        System.out.println(pc);
    }
}
```

---

## **Comparison of Implementations**
| Approach | Pros | Cons |
|----------|------|------|
| **Static Nested Class (Traditional Builder)** | Readable, Immutable, Encapsulated | More boilerplate |
| **Lombok `@Builder`** | Less code, easy to use | Requires Lombok dependency |
| **Separate Builder Class** | Good for extending interfaces | Less encapsulated |
| **Functional (Lambda) Builder** | Clean syntax, flexible | May be less readable for complex objects |

---

### **Which One Should You Use?**
- âœ… Use **Traditional Static Builder** for **strong encapsulation** and **immutability**.
- âœ… Use **Lombok Builder** if you want **less boilerplate**.
- âœ… Use **Separate Builder Class** if you need to **extend interfaces**.
- âœ… Use **Functional (Lambda) Builder** for **concise and flexible object creation**.

Would you like an implementation for a specific use case? ðŸš€
